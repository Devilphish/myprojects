<!DOCTYPE html>
<html>
<head>
<meta name="viewport" content="width=device-width, first-scale=1.0"/>
<style>

</style>
</head>
<body onload="startPuzzle()">

<img id="Tile1.png">
<img id="Tile2.png">
<img id="Tile3.png">
<img id="Tile4.png">
<img id="Tile5.png">
<img id="Tile6.png">
<img id="Tile7.png">
<img id="Tile8.png">
<img id="Tile9.png">

<script>

// 1 = Harry
// 2 = Nick
// 3 = Brendon
// 4 = Taylor
// Solutions:
// deck: 11 31 21 53 41 03 83 63 73 
// deck: 20 02 72 30 40 62 10 52 82 
// deck: 71 61 81 01 43 51 23 33 13 
// deck: 80 50 12 60 42 32 70 00 22 

var sq = [
    [-1, 2, 3, -4],
    [-1, 4, 2, 1],
    [-4, -2, 3, 2],
    [-3, -4, 1, 3],
    [1, -2, -3, 4],
    [1, -4, 3, 2],
    [3, 2, -1, -4],
    [1, 4, 3, -2],
    [-4, -2, -3, -1]
];

var tilesWith =  [
    [ 0, 2, 3, 5, 6, 8, ],  // -4
    [ 3, 4, 8, ],           // -3
    [ 2, 4, 7, 8, ],        // -2
    [ 0, 1, 6, 8, ],        // -1
    [],                     //  0
    [ 1, 3, 4, 5, 7, ],     //  1
    [ 0, 1, 2, 5, 6, ],     //  2
    [ 0, 2, 3, 5, 6, 7, ],  //  3
    [ 1, 4, 7, ]            //  4
];
var tilesWithIndex = [
    0, 0, 0, 0, 0, 0, 0, 0, 0
];

var cmps = [
    [[0, 1], [1, 3]],
    [[1, 1], [2, 3]],

    [[0, 2], [3, 0]],
    [[1, 2], [4, 0]],
    [[2, 2], [5, 0]],

    [[3, 1], [4, 3]],
    [[4, 1], [5, 3]],

    [[3, 2], [6, 0]],
    [[4, 2], [7, 0]],
    [[5, 2], [8, 0]],

    [[6, 1], [7, 3]],
    [[7, 1], [8, 3]],
];

var backCmpsForTile = [
    [],
    [[[0, 1], [1, 3]]],
    [[[1, 1], [2, 3]]],
    [[[0, 2], [3, 0]]],
    [[[1, 2], [4, 0]], [[3, 1], [4, 3]]],
    [[[2, 2], [5, 0]], [[4, 1], [5, 3]]],
    [[[3, 2], [6, 0]]],
    [[[4, 2], [7, 0]], [[6, 1], [7, 3]]],
    [[[5, 2], [8, 0]], [[7, 1], [8, 3]]],
];

var fwdCmpsForTile = [
    [[[0, 1], [1, 3]]],
    [[[1, 1], [2, 3]]],
    [[[2, 2], [5, 0]]],
    [[[3, 2], [6, 0]]],
    [[[4, 3], [3, 1]], [[3, 0], [0, 2]]],
    [[[5, 3], [4, 1]], [[4, 0], [1, 2]]],
    [[[6, 1], [7, 3]], [[7, 0], [4, 2]]],
    [[[7, 1], [8, 3]], [[8, 0], [5, 2]]],
    []
];

var prevtile = [
    -1, 0, 1, 4, 5, 2, 3, 6, 7
];

var p = [];
var deck = [];
var rots = [];
var board = [];

var statusmsg;
var debugmsg;
var turnmsg;

var fpcount = 0;
var count = 0;
var animationInterval = 50;

function test(ncmps)
{
    var ncmpsnew = ncmps - 1;
    var p0;
    var p1;
    var r0;
    var r1;
    var t0;
    var t1;

    t0 = cmps[ncmpsnew][0][0];
    t1 = cmps[ncmpsnew][1][0];
    p0 = cmps[ncmpsnew][0][1];
    p1 = cmps[ncmpsnew][1][1];
    r0 = (p0 - rots[t0] + 4) % 4;
    r1 = (p1 - rots[t1] + 4) % 4;

    if (sq[deck[t0]][r0] == -sq[deck[t1]][r1]) {
        if (ncmpsnew) {
            if (test(ncmpsnew)) {
                return true;
            }
        }
        else {
            // GOT IT
            alert("GOT IT!");

            statusmsg.innerHTML = "GOT IT!";
            turnmsg.innerHTML = "";
            for (var t = 0; t < 3; t++) {
                turnmsg.innerHTML += deck[t] + "" + rots[t] + " ";
            }
            turnmsg.innerHTML += "\n";
            for (var t = 3; t < 6; t++) {
                turnmsg.innerHTML += deck[t] + "" + rots[t] + " ";
            }
            turnmsg.innerHTML += "\n";
            for (var t = 6; t < 9; t++) {
                turnmsg.innerHTML += deck[t] + "" + rots[t] + " ";
            }
            turnmsg.innerHTML += "\n";

            return true;
        }
    }

    return false;
}

function rotate(ntiles)
{
    var ntilesnew = ntiles - 1;

    for (var r = 0; r < 4; r++) {
        rots[ntilesnew] = r;

        if (ntilesnew) {
            if (rotate(ntilesnew)) {
                return true;;
            }
        }
        else {
            if (test(12)) {
                return true;
            }
        }
    }

    return false;
}

function permute(ntiles, tiles)
{
    var newtiles = [];
    var ntilesnew = ntiles - 1;

    for (var t = 0; t < ntiles; t++) {
        deck[ntilesnew] = tiles[t];

        for (var x = 0; x < t; x++) {
            newtiles[x] = tiles[x];
        }
        for (var x = t; x < ntilesnew; x++) {
            newtiles[x] = tiles[x+1];
        }

        if (ntilesnew) {
            if (permute(ntilesnew, newtiles)) {
                return true;;
            }
        }
        else {
            count++;

            if (rotate(9)) {
                renderDeck(9);

                return true;
            }
        }
    }

    return false;
}

function iterate(curtile, tiles)
{
    for (var t = curtile; t < 9; t++) {
        deck[curtile] = tiles[t];

        for (var r = 0; r < 4; r++) {
            rots[curtile] = r;
            renderDeck(curtile + 1);
            var cmpsGood = true;
            for (var i = 0; i < backCmpsForTile[t].length; i++) {
                var t0;
                var t1;
                var p0;
                var p1;
                var r0;
                var r1;
                var cmp = backCmpsForTile[t][i];

                t0 = cmp[0][0];
                t1 = cmp[1][0];
                p0 = cmp[0][1];
                p1 = cmp[1][1];
                r0 = (rots[t0] + p0) % 4;
                r1 = (rots[t1] + p1) % 4;

                if (sq[deck[t0]][r0] != -sq[deck[t1]][r1]) {
                    cmpsGood = false;
                    break;
                }
            }

            if (cmpsGood) {
                if (curtile < 8) {
                    if (iterate(curtile + 1, tiles)) {
                        return true;;
                    }
                }
                else {
                    // GOT IT
                    statusmsg.innerHTML = "GOT IT!";
                    turnmsg.innerHTML = "";
                    for (var t = 0; t < 3; t++) {
                        turnmsg.innerHTML += deck[t] + "" + rots[t] + " ";
                    }
                    turnmsg.innerHTML += "\n";
                    for (var t = 3; t < 6; t++) {
                        turnmsg.innerHTML += deck[t] + "" + rots[t] + " ";
                    }
                    turnmsg.innerHTML += "\n";
                    for (var t = 6; t < 9; t++) {
                        turnmsg.innerHTML += deck[t] + "" + rots[t] + " ";
                    }
                    turnmsg.innerHTML += "\n";
        
                    return true;
                }
            }
        }
    }

    return false;
}

function tilesetBorder(tileset, enable)
{
    for (var i = 0; i < tileset.length; i++) {
        if (enable) {
            p[tileset[i]].image.src = "Tile" + (tileset[i] + 1) + "_hi.png";
        }
        else {
            p[tileset[i]].image.src = "Tile" + (tileset[i] + 1) + ".png";
        }
    }
}


var tileUsed = [
    false,
    false,
    false,
    false,
    false,
    false,
    false,
    false,
    false,
];

var curtile;
var firstTile;
var firstRot;
var iId = null;
var tilesWithArray;

function followPath()
{
    if (curtile == 8) {
        clearInterval(iId);
        iId = null;

        alert("GOT IT!");

        return false;
    }

    fpcount++;

    var newFirst;

    if (deck[0] != -1) {
        newFirst = false;
        tileUsed[deck[0]] = false;
    }
    else {
        newFirst = true;
    }
    deck[0] = firstTile;;
    rots[0] = firstRot;
    tileUsed[firstTile] = true;

    renderDeck();

    if (newFirst) {
        return true;
    }

    var nexttile = fwdCmpsForTile[curtile][0][1][0];
    var p1 = fwdCmpsForTile[curtile][0][1][1];

    var p0 = fwdCmpsForTile[curtile][0][0][1];
    var r0 = (p0 - rots[curtile] + 4) % 4;
    var face = sq[deck[curtile]][r0];

    while (tilesWithIndex[curtile] < tilesWithArray.length &&
           tileUsed[tilesWithArray[tilesWithIndex[curtile]]]) {
        tilesWithIndex[curtile]++;
    }
    if (tilesWithIndex[curtile] == tilesWithArray.length) {
        var tilenum = deck[curtile];

        if (board[nexttile].tile != -1) {
            var t = p[board[nexttile].tile];
            t.image.rot = 0;
            t.image.style.rotate = t.image.rot + "deg";
            t.image.style.opacity = "1.0";

            t.image.style.width = t.trayw + "px";
            t.image.style.height = t.trayh + "px";
            t.image.style.left = t.trayx + "px";
            t.image.style.top = t.trayy + "px";

            board[nexttile].tile = -1;
        }

        p[tilenum].image.rot = 0;
        p[tilenum].image.style.rotate = p[tilenum].image.rot + "deg";
        p[tilenum].image.style.opacity = "1.0";

        p[tilenum].image.style.width = p[tilenum].trayw + "px";
        p[tilenum].image.style.height = p[tilenum].trayh + "px";
        p[tilenum].image.style.left = p[tilenum].trayx + "px";
        p[tilenum].image.style.top = p[tilenum].trayy + "px";

        tileUsed[deck[curtile]] = false;
        deck[curtile] = -1;

        renderDeck();

        tilesetBorder(tilesWithArray, false);

        if (curtile == 0) {
            firstRot++;
            tilesWithIndex[0] = 0;
            if (firstRot == 4) {
                firstRot = 0;
                firstTile++;
                if (firstTile == 9) {
                    // shouldn't ever get here (bad tiles?)
                    clearInterval(iId);
                    iId = null;

                    alert("ERROR: solution 404!\nBAD TILE DECK");

                    return false;
                }
            }
            deck[0] = firstTile;
            rots[0] = firstRot;
            tileUsed[firstTile] = true;
        }
        else {
            curtile = prevtile[curtile];
            p[deck[curtile]].image.style.opacity = "0.7";
        }

        if (tilesWithArray != undefined) {
            tilesetBorder(tilesWithArray, false);
        }
        p0 = fwdCmpsForTile[curtile][0][0][1];
        r0 = (p0 - rots[curtile] + 4) % 4;
        face = sq[deck[curtile]][r0];
        tilesWithArray = tilesWith[-face + 4];
        tilesetBorder(tilesWithArray, true);
    }
    else {
        if (fwdCmpsForTile[curtile].length > 1) {
            // compare "other" faces in fwd list
            var tf1 = fwdCmpsForTile[curtile][1][1][0];
            var pf0 = fwdCmpsForTile[curtile][1][0][1];
            var pf1 = fwdCmpsForTile[curtile][1][1][1];
            var t = tilesWithArray[tilesWithIndex[curtile]];
            var x = sq[t].indexOf(-face);
            var r = (p1 - x + 4) % 4;
            var rf0 = (pf0 - r + 4) % 4;
            var rf1 = (pf1 - rots[tf1] + 4) % 4;

            if (board[nexttile].tile != -1) {
                var tile = p[board[nexttile].tile];
                tile.image.rot = 0;
                tile.image.style.rotate = tile.image.rot + "deg";
                tile.image.style.opacity = "1.0";

                tile.image.style.width = tile.trayw + "px";
                tile.image.style.height = tile.trayh + "px";
                tile.image.style.left = tile.trayx + "px";
                tile.image.style.top = tile.trayy + "px";

                board[nexttile].tile = -1;
            }

            p[t].image.rot = r * 90;
            p[t].image.style.rotate = p[t].image.rot + "deg";
            p[t].image.style.opacity = "0.7";

            p[t].image.style.width = board[nexttile].w + "px";
            p[t].image.style.height = board[nexttile].h + "px";
            p[t].image.style.left = board[nexttile].x + "px";
            p[t].image.style.top = board[nexttile].y + "px";
            board[nexttile].tile = t;

            if (sq[t][rf0] != -sq[deck[tf1]][rf1]) {
                tilesWithIndex[curtile]++;

                return true;
            }
        }

        if (deck[nexttile] != -1) {
            tileUsed[deck[nexttile]] = false;
        }
        deck[nexttile] = tilesWithArray[tilesWithIndex[curtile]];
        var x = sq[deck[nexttile]].indexOf(-face);
        rots[nexttile] = (p1 - x + 4) % 4;
        tilesWithIndex[curtile]++;
        tileUsed[deck[nexttile]] = true;

        renderDeck();

        curtile = nexttile;
        tilesWithIndex[curtile] = 0;

        if (curtile != 8) {
            if (tilesWithArray != undefined) {
                tilesetBorder(tilesWithArray, false);
            }

            p0 = fwdCmpsForTile[curtile][0][0][1];
            r0 = (p0 - rots[curtile] + 4) % 4;
            face = sq[deck[curtile]][r0];
            tilesWithArray = tilesWith[-face + 4];

            tilesetBorder(tilesWithArray, true);
        }
        else {
            if (tilesWithArray != undefined) {
                tilesetBorder(tilesWithArray, false);
            }
        }
    }

    return true;
}

function solve(animate)
{
    var tiles = [];

    for (var t = 0; t < 9; t++) {
        tiles[t] = t;
        deck[t] = -1;
        rots[t] = -1;
    }
    fpcount = 0;

//    permute(9, tiles);
//    iterate(0, tiles);

    var p0 = fwdCmpsForTile[0][0][0][1];
    var face = sq[0][p0];
    tilesWithArray = tilesWith[-face + 4];

    curtile = 0;
    firstTile = 0;
    firstRot = 0;

    if (animate) {
        iId = setInterval(followPath, animationInterval);
    }
    else {
        while (followPath()) {
            ;
        }
    }
}

var paused = false;

function keyDownEvent(e)
{
    statusmsg.innerHTML = "foo " + e.code;
    if (e.code == "KeyR") {
        curtileImage.rot += 90;
        if (curtileImage.rot == 360) curtileImage.rot = 0;
        curtileImage.style.rotate = curtileImage.rot + "deg";

        test(12);
    }
    if (e.code == "KeyS") {
        if (iId == null) {
            solve(true);
        }
    }
    if (e.code == "KeyF") {
        if (iId == null) {
            solve(false);
        }
    }
    if (e.code == "KeyC") {
        if (iId == null) {
            if (curtile == 8) {
                curtile = prevtile[8];;
                tileUsed[deck[8]] = false;
                deck[8] = -1;
                iId = setInterval(followPath, animationInterval);
            }
        }
    }
    if (e.code == "KeyP") {
        if (iId != null) {
            if (!paused) {
                clearInterval(iId);
                paused = true;
            }
            else {
                iId = setInterval(followPath, animationInterval);
                paused = false;
            }
        }
    }
    if (e.code == "KeyJ") {
        if (paused) {
            followPath();
        }
    }
    if (e.code == "KeyD") {
        debugmsg.innerHTML = "deck: ";
        for (var i = 0; i < 9; i++) {
            if (deck[i] != -1) {
                var t = deck[i];
                var r = p[t].image.rot / 90;
                debugmsg.innerHTML += t + ""  + r + " ";
            }
        }
    }
}

function keyUpEvent(e)
{
}

function startPuzzle()
{
    window.addEventListener('keydown', keyDownEvent);
    window.addEventListener('keyup', keyUpEvent);
    document.body.style.backgroundColor = "#7171f1";

    debugmsg = document.getElementById('debuglog');
    debugmsg.style.position = "absolute";
    debugmsg.style.top = "760px";
    statusmsg = document.getElementById('statuslog');
    statusmsg.style.position = "absolute";
    statusmsg.style.top = "780px";
    statusmsg.innerHTML = "foo";
    turnmsg = document.getElementById('turnlog');
    turnmsg.style.position = "absolute";
    turnmsg.style.top = "800px";

    for (var i = 0; i < 9; i++) {
        var tw = 100;
        var th = 100;
        var tx = 855 + ((i % 2) * 110);
        var ty = 50 + (Math.floor(i / 2) * 110);
        var tileName = "Tile" + (i + 1) + ".png";
        p[i] = new tile(tw, th, tileName, tx, ty, "image", 0, 0);
        p[i].trayw = tw;
        p[i].trayh = tw;
        p[i].trayx = tx;
        p[i].trayy = ty;

        var x = 55 + ((i % 3) * 250);
        var y = 5 + (Math.floor(i / 3) * 250);
        board[i] = {};
        board[i].w = 250;
        board[i].h = 250;
        board[i].x = x;
        board[i].y = y;
        board[i].tile = -1;
    }
}

function renderDeck()
{
    debugmsg.innerHTML = "deck: ";
    for (var i = 0; i < 9; i++) {
        if (deck[i] != -1) {
            var tile = p[deck[i]];
            tile.image.rot = rots[i] * 90;
            tile.image.style.rotate = tile.image.rot + "deg";
            tile.image.style.opacity = "1.0";
            tile.image.style.width = board[i].w + "px";
            tile.image.style.height = board[i].h + "px";
            tile.image.style.left = board[i].x + "px";
            tile.image.style.top = board[i].y + "px";
            board[i].tile = deck[i];;
            debugmsg.innerHTML += deck[i] + "" + rots[i] + " ";
        }
    }
}

var curtileImage = null;
var selectedTile = null;

function swapTiles(t1, t2)
{
}

function tileEnter()
{
    curtileImage = this;
}

function tileDownEvent()
{
    if (selectedTile != null) {
        saverot = this.rot;
        savesrc = this.src;

        this.rot = selectedTile.rot;
        this.style.rotate = this.rot + "deg";
        this.src = selectedTile.src;

        selectedTile.rot = saverot;
        selectedTile.style.rotate = selectedTile.rot + "deg";
        selectedTile.src = savesrc;

        selectedTile.style.opacity = "1.0";

        selectedTile = null;

        test(12);
    }
    else {
        selectedTile = this;
        this.style.opacity = "0.7";
    }
}

function tile(width, height, image, x, y, type, xoffset, yoffset)
{
    this.image = document.getElementById(image);
    this.image.addEventListener("mouseenter", tileEnter);
    this.image.addEventListener("mousedown", tileDownEvent);
    this.image.rot = 0;
    this.image.src = image;
    this.image.style.position = "absolute";
    this.image.style.left = x + "px";
    this.image.style.top = y + "px";
    this.image.style.width = width + "px";
    this.image.style.height = height + "px";
}

</script>

<div style="text-align:center;width:480px;">
  <pre id="debuglog" font-weight="bold"> X:  Y:  </pre>
  <pre id="statuslog"></pre>
  <pre id="turnlog"> player: </pre>
</div>
</body>
</html>
